设置读操作超时场景——多次连接

同时，这也是一个典型的**长连接程序**，可以看到，当连接没有断掉时，可以一直通过连接发送数据。

先启动服务端：`go run base/6.readtimeoutmore/server/main.go`

再启动客户端：`go run base/6.readtimeoutmore/client/main.go`

**客户端行为：**

* 客户端启动后，调用 `net.Dial("tcp", ":8888")` 成功建立与服务端的 TCP 连接，并打印“dial ok”。
* 进入 for 循环，总共执行两次。
* 每次循环开始时都会 **暂停 5 秒**（`time.Sleep(5 * time.Second)`)。
* 然后调用 `conn.Write([]byte("hello"))` 发送固定字节串 `"hello"`（5 个字节）到服务端，并打印写入时间和写入字节数。
* 两次写入后，客户端的 `main` 结束，调用 `defer conn.Close()` 关闭连接。

**服务端行为：**

* 服务端启动后，通过 `net.Listen("tcp", ":8888")` 在 8888 端口监听，并进入接收连接的无限循环。
* 当客户端连接上来时，服务端打印“接收到一个新的连接”，并启动一个新的 goroutine 执行 `handleConn` 函数。

**handleConn**函数的流程：

**1. 初始打印与循环开始**

* 立即打印“准备读取...”。
* 进入无限循环，每次循环为本次读取新建一个大小为 10 字节的缓冲区。

**2. 设置读取截止时间（Deadline）**

* 每次循环开始时，调用 `c.SetReadDeadline(time.Now().Add(3 * time.Second))`
   这意味着服务端在每次调用 `c.Read(buf)` 后最多等待 3 秒数据到来。

**3. 第一次读取（循环第一次迭代）**

* 服务端设置截止时间后开始读取，但此时客户端还处于 5 秒休眠中，因此没有数据到达。

* 经过 3 秒，`Read` 返回一个超时错误（通常是 `i/o timeout`）。

* 代码检测到错误后，通过类型断言确认错误为超时（`nerr.Timeout()` 为 true），因此打印类似下面的信息（时间会按实际情况显示）：

  ```
  bash复制编辑读取发生错误：i/o timeout
  2025-04-08 15:04:05.123  发生读超时
  ```

* 随后进入下一次循环，继续等待数据。

**4. 第二次读取（客户端第一次发送数据）**

* 客户端在 5 秒后发送第一个 `"hello"`（5 字节）。

* 此时服务端正在新的循环迭代中：

  * 调用 `SetReadDeadline` 时以当前时间（假设大约 3 秒左右）加 3 秒（截止 6 秒左右）。
  * 当客户端发送数据到达后，`Read` 能够在截止时间内成功读取到数据（读取到 `"hello"`，5 个字节）。

* 服务端打印类似如下信息（时间为实际的）：

  ```
  yaml
  
  
  复制编辑
  2025-04-08 15:04:06.456 已读取 5 字节
  ```

**5. 第三次读取（等待第二个数据发送）**

* 再次进入循环，服务端重新设置新的截止时间（以当前时间加 3 秒，假定此时截止时间大约在客户端第二次写入之前）。

* 客户端在第二次循环迭代中等待 5 秒后发送第二个 `"hello"`。

* 由于服务端的截止时间为 3 秒，而客户端发送数据的间隔为 5 秒，此轮循环内可能再次发生超时：

  * 如果服务端设置截止时间后，客户端还未写入数据，`Read` 调用超时，返回 `i/o timeout` 错误。

  * 服务端检测到超时，打印错误信息以及超时提示：

    ```
    bash复制编辑读取发生错误：i/o timeout
    2025-04-08 15:04:09.789  发生读超时
    ```

  * 然后继续循环，重新设置截止时间等待数据。

**6. 第四次读取（接收客户端第二个数据）**

* 进入新的循环迭代后，服务端再次调用 `SetReadDeadline`，截止时间设在当前时间 +3 秒。

* 此时客户端的第二个 `"hello"`数据已经在TCP缓冲区中（客户端在 5 秒后写入，实际时间可能稍晚于第一次发送，但由于上一次循环超时后，服务端马上重新尝试读取，新的截止时间足够接收缓存中的数据）。

* 服务端调用 `Read` 成功读取到第二个 `"hello"`（5 字节），打印：

  ```
  yaml
  
  
  复制编辑
  2025-04-08 15:04:11.012 已读取 5 字节
  ```

**7. 后续处理和连接关闭**

* 客户端写入完毕后结束并关闭连接。

* 服务端下一次 `Read` 调用时检测到连接关闭，会返回非超时错误（如 `EOF`），打印错误信息：

  ```
  复制编辑
  读取发生错误：EOF
  ```

* 随后，`handleConn` 函数退出，关闭当前连接。

![image-20250408124814149](http://images.liangning7.cn/typora/202504081248215.png)